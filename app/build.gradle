import java.nio.file.Files
import java.nio.file.Paths
import java.util.regex.Pattern
import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream
import java.util.zip.ZipOutputStream

apply plugin: 'apk-conventions'

android {
    namespace 'com.mirfatif.permissionmanagerx'

    defaultConfig {
        applicationId namespace

        versionCode libs.versions.app.code.get().toInteger()
        versionName libs.versions.app.name.get()

        // Flavor-independent and BuildType-independent BuildConfig.APPLICATION_ID
        buildConfigField 'String', 'APP_ID', '"' + namespace + '"'

        // Daemon dex file to be saved in assets directory.
        buildConfigField 'String', 'DAEMON_DEX', '"' + daemonDex + '"'

        versionNameSuffix '-foss'
    }

    buildTypes {
        debug {
            applicationIdSuffix '.debug'
            versionNameSuffix '-debug'
        }
    }

    applicationVariants.configureEach { variant ->
        def mf = variant.mergedFlavor
        String lfp = variant.applicationId + '.LogFileProvider'
        mf.addManifestPlaceholders(LOG_FILE_PROVIDER: lfp)
        variant.buildConfigField 'String', 'LOG_FILE_PROVIDER', '"' + lfp + '"'
    }

    packagingOptions {
        jniLibs {
            // Due to android:extractNativeLibs set to 'true' in AndroidManifest.
            useLegacyPackaging true
        }

        // Exclude large files.
        resources.excludes.add('org/bouncycastle/pqc/crypto/picnic/lowmcL1.bin.properties')
        resources.excludes.add('org/bouncycastle/pqc/crypto/picnic/lowmcL3.bin.properties')
        resources.excludes.add('org/bouncycastle/pqc/crypto/picnic/lowmcL5.bin.properties')
    }
}

configurations {
    configureEach {
        // To avoid duplicate class version conflict.
        exclude group: 'androidx.lifecycle', module: 'lifecycle-viewmodel-ktx'
    }
}

dependencies {
    implementation project(path: ':priv_library')

    implementation libs.libadb.android
    // To generate X509Certificate
    implementation libs.sun.security.android
    // For conscrypt
    implementation libs.hiddenapibypass

    implementation libs.androidx.appcompat
    implementation libs.androidx.recyclerview
    implementation libs.androidx.swiperefreshlayout
    implementation libs.androidx.preference
    implementation libs.androidx.browser
    implementation libs.androidx.room.runtime
    implementation libs.androidx.security.crypto
    implementation libs.androidx.webkit
    annotationProcessor libs.androidx.room.compiler

    // For SnackBar and NavigationView. Also includes CoordinatorLayout
    implementation libs.material

    // To handle hyperlink onClick in TextView
    implementation libs.better.link.movement.method

    // To use Iterables for splitting Collections
    implementation(libs.guava)

    // Let's behave responsibly
    debugImplementation libs.leakcanary.android
}

def createJarFromApk(String apkFile, String jarFile) {
    try (ZipInputStream apk = new ZipInputStream(new FileInputStream(apkFile))) {
        try (ZipOutputStream jar = new ZipOutputStream(new FileOutputStream(jarFile))) {
            ZipEntry entry
            Pattern clsDex = Pattern.compile("classes[0-9]*.dex")
            int len
            byte[] buf = new byte[1024]

            while ((entry = apk.nextEntry) != null) {
                if (entry.name.matches(clsDex)) {
                    jar.putNextEntry(new ZipEntry(entry.name))
                    while ((len = apk.read(buf)) > 0) {
                        jar.write(buf, 0, len)
                    }
                    jar.closeEntry()
                }
                apk.closeEntry()
            }
        }
    }

    println("Jar created: $jarFile")
}

def copyFileIfChanged(File src, File dst) {
    assert src.file
    assert !dst.exists() || dst.file

    if (dst.exists()) {
        byte[] s = Files.readAllBytes(Paths.get(src.absolutePath))
        byte[] d = Files.readAllBytes(Paths.get(dst.absolutePath))
        if (Arrays.equals(s, d)) {
            println('UP-TO-DATE: ' + dst.absolutePath)
            return
        }

        delete dst
    }

    copy {
        from src
        into dst.parentFile
        rename { fileName -> dst }
    }

    if (dst.exists()) {
        println('Creating: ' + dst.absolutePath)
    } else {
        throw new GradleException('Failed to create: ' + dst.absolutePath)
    }
}

def createTasksForDaemonBuild = () -> {
    boolean signed = project.hasProperty('android.injected.signing.store.file')

    for (boolean debug : new boolean[]{true, false}) {
        String task = debug ? 'Debug' : 'Release'

        String dir = debug ? 'debug' : 'release'

        String dexTaskDep = 'assemble' + task

        String apk = 'priv_daemon/build/outputs/apk/'
        apk += (debug ? 'debug' : 'release') + '/priv_daemon'
        apk += (debug ? '-debug' : ('-release' + (signed ? '' : '-unsigned'))) + '.apk'

        String jar = apk.replace('.apk', '.jar')

        File srcFile = new File(rootDir, jar)
        File dstFile = new File(rootDir, 'app/src/' + dir + '/assets/' + daemonDex)

        Task t = tasks.register('buildDaemon' + task) {
            dependsOn(':priv_daemon:' + dexTaskDep)
            mustRunAfter(':priv_daemon:' + dexTaskDep)

            ext.srcFile = srcFile
            ext.dstFile = dstFile

            doLast {
                createJarFromApk(apk, jar)
            }
        }.get()

        t.doLast {
            copyFileIfChanged(srcFile, dstFile)
        }
    }
}

tasks.register('buildNative', Exec) {
    environment 'ANDROID_NDK', ndkDir
    workingDir nativeDir
    commandLine './build_native.sh'

    doLast {
        if (executionResult.get().exitValue != 0) {
            throw new GradleException('buildNative failed')
        }
    }
}

def setExtSrcDependencies() {
    for (boolean debug : new boolean[]{true, false}) {
        String build = debug ? 'Debug' : 'Release'

        TaskProvider task = tasks.named('merge' + build + 'Assets')

        task.configure {
            dependsOn('buildDaemon' + build)
            mustRunAfter('buildDaemon' + build)
        }

        task = tasks.named('merge' + build + 'JniLibFolders')

        task.configure {
            dependsOn('buildNative')
            mustRunAfter('buildNative')
        }
    }
}

createTasksForDaemonBuild()

afterEvaluate {
    setExtSrcDependencies()
}

clean.doLast {
    // Delete daemon dex
    for (String variant in new String[]{'release', 'debug'}) {
        Paths.get(projectDir.absolutePath, 'src/' + variant + '/assets').deleteDir()
    }
    Paths.get(projectDir.absolutePath, 'src/main/jniLibs').deleteDir()
}

preBuild.doFirst {
    // Re-merge the assets and jniLibs source sets.
    for (String dir in new String[]{'assets', 'merged_jni_libs'}) {
        Paths.get(projectDir.absolutePath, 'build/intermediates/' + dir).deleteDir()
    }
}
